# 형변환(Conversion)
## 정의
- 형변환(Type Conversion)이란 프로그램에서 서로 다른 자료형(Type) 간의 값을 주고 받을 때 발생하는
  데이터 표현 방식의 차이를 보정하기 위해 값을 적절히 변환하는 작업
- 예를 들어 32비트 정수(int) 값을 64비트 정수(long) 변수에 담거나, 반대로 64비트 값을 32비트 변수에
    담으려면 반드시 변환 과정을 거쳐야만 함.

## 필요성
1. 메모리 최적화
   - 작은 타입에만 저장해도 충분한 값이라면, 더 큰 타입을 쓰는 것은 메모리 낭비이기 때문에.
   - 반대로, 큰 범위의 값이 필요할 때 작은 타입으로만 프로그램을 짜면 표현할 수 없는 값이 생깁니다.

2. API 호환성
   - 예를 들어, 외부 라이브러리 메서드가 `long`을 받아들일 때, 우리 쪽에서 `int` 값을 넘기면 자동
     (암시적)으로 `long`으로 변환해줘야 합니다.

3. 연산 정확도
    - 소수점 연산을 위해 `float→double`으로 확장하거나, 반대로 저장 공간을 줄이기 위해
        `double→float`으로 축소하는 사례가 많습니다. (이모지 사용법 : window + .)
   
# 업캐스팅(Upcasting) vs. 다운캐스팅(Downcasting)
## 업캐스팅(Upcasiting, Widening Conversion)
### 정의 
- 메모리 용량(비트 크기)이 작은 타입 → 더 큰 타입으로 변환

### 특징
- 메모리 여유가 생기므로, 원본 값이 손실 없이 모두 표현 가능
- 암시적(implicit) 변환이 기본 제공

## 다운캐스팅(Downcasting, Narrowing Conversion)
### 정의
- 메모리 용량이 큰 타입 → 더 작은 타입으로 변환

### 특징
- 표현할 수 있는 값의 범위가 줄어들기 때문에, 변환 과정에서 데이터 손실(overflow/underflow) 위험 발생
- 따라서 명시적(explicit) 캐스트 연산자로만 수행 가능함.

| 타입   | 크기 (bits) | 부호     | 표현 범위                                      | 비고                         |
|:------:|:-----------:|:--------:|:-----------------------------------------------|:-----------------------------|
| byte   | 8           | ✔︎       | -128 ~ 127                                     | 정수형 최소 단위             |
| short  | 16          | ✔︎       | -32,768 ~ 32,767                               |                              |
| char   | 16          | ✘        | 0 ~ 65,535                                     | 유니코드 문자 저장 용도      |
| int    | 32          | ✔︎       | -2³¹ ~ 2³¹-1                                   | 약 -21억 ~ +21억             |
| long   | 64          | ✔︎       | -2⁶³ ~ 2⁶³-1                                   | 약 -9.22×10¹⁸ ~ +9.22×10¹⁸   |
| float  | 32          | IEEE 754 | 약 ±1.4×10⁻⁴⁵ ~ ±3.4×10³⁸ (유효숫자 ≈ 7자리)     | 단정도 (single-precision)    |
| double | 64          | IEEE 754 | 약 ±4.9×10⁻³²⁴ ~ ±1.7×10³⁰⁸ (유효숫자 ≈ 15자리) | 배정도 (double-precision)    |

# 조건문(Condition)
 ## if문 
f 다음에 있는 () 내의 조건식이 ture 일  때 {} 내의 실행문이 실행됨.
false면 실행 x

    형식 :
    if(조건식) { 조건식 : true / false 로 결론이 날 수 있는 식 또는 문장 실행문}
 ## if - else 문  
if 다음에 있는 조건식이 true 일 때는 if문 내의 {} 실행문이 실행
/ false 인 경우에는 else에 딸린 {} 실행문이 실행
    
    예시 :
    Scanner scanner = new Scanner(System.in);
    //논리 연산자 사용
    System.out.print("연도를 입력하세요 >>>");
    int year = scanner.nextInt();
    String leapyear = "";

        if((year % 4 == 0 && year % 100 != 0)|| (year % 400 == 0)){
            leapyear = "윤년입니다.";
        }else{                          //4로 나누어 떻어지지 않거나 // 100으로 나누어지거나
            leapyear = "윤년이 아닙니다.";
        }
        System.out.println(year + "년은" + leapyear)
 ## if - else if문 
if - else 문과 달리 else if 에는 별도의 조건식이 요구됨.
    
    형식 :
    if(조건식1) {
            실행문1
    }else if(조건식2) {                
        실행문2
    } else if(조건식3) {
        실행문3
    }else {
        실행문4

    예시:
    if(score > 100){
        grade = "X";

        }else if (score < 0){
            grade = "X";

        } else if (score > 89) {
            grade = "A학점";

        }else if(score > 79){
            grade = "B학점";

        }else if (score > 69) {
            grade = "C학점";

        }else if (score > 59){
            grade = "D학점";

    }else {
        grade = "F학점";
## 중첩 if 문(Nested - if)
if문 내에 if 문이 연속적으로 작성될 수 있습니다.

    형식 :
    if(조건식1){
        실행문1
        if(조건식1a){
            실행문1a
        } else if (조건식1b) {
            실행문1b
        }else if (조건식1c){
            실행문1c
        }else {
            실행문1d
        }
    }else if (조건식2) {
        실행문2
        if(조건식2a) {
            실행문 2a
    } else {
        실행문2b
    } else {
        실행문3

        if(조건식3a) {
            실행문3a
      }
    }

    예시:
    if(score > 100 || score < 0) {
            System.out.println("불가능한 점수 입력입니다.");
            grade = "X";
        }else {                                 
            if (score > 89) {
                grade = "A학점";
            } else if (score > 79) {
                grade = "B학점";
            } else if (score > 69) {
                grade = "C학점";
            } else if (score > 59) {
                grade = "D학점";
            } else {
                grade = "F학점";
            }
        }
## 삼항 연산자

  정의 : 조건식을 평가하여 true / false 에 따라 두가지 표현식중 하나를 선택적으로 실행

         형식:
         조건식 ? 표현식1 : 표현식2;

         조건식 : true / false 로 평가 가능한 식
         표현식1 : 조건식이 true 일 때 실행되는 식
         표현식2 : 조건식이 false 일 때 실행되는 식

    예시 :
        Scanner scanner = new Scanner(System.in);
        System.out.print("연도를 입력하세요 >>>>");
        int year = scanner.nextInt();
      
       `논리 자료형(boolean)
         변수 : 참 / 거짓 ( true / false )
         자료형 변수명      = 데이터;      

        boolean
        //bolean 자료형의 변수명은 is로 시작하는 일이 많습니다.
        boolean [변수명] isLeapYear  = [조건식/데이터]((year % 4 == 0 && year % 100 != 0)|| (year % 400 == 0)); 
            변수명에 조건식을 대입  , 조건식이 true 그 외를 false로 한다

        String result = isLeapYear ? [표현식1]"윤년입니다" : [표현식2]"윤년이 아닙니다";

    음수 연도를 걸러내기

        String result2 = "";
         if(year < 0) {
            result2 = "불가능한 연도 입력입니다.";
         }else {        <- 얘는 0 이상
             result2 = isLeapYear ? "윤년입니다" : "윤년이 아닙니다."; <-여기에 삼항 연산자 쓰면 된다
         }
        System.out.println(year+ "년은 " +result2);
    }
## switch 문

    형식 :
        switch(변수명)
        case 조건1:
        실행문1
        break;
        case 조건2:
        실행문2
        break;
        case 조건3:
        실행문3
        break;
        case 조건4:
        실행문4
        break;
        default:
        실행문5
  
    예시:
        if(score < 0 || score > 100) {
        grade = "x";
        }else {                 // 0<= score <= 100의 범위를  충족하면 이하의 실행문이 실행됨
        switch (changedScore) {
        case 10:
        case 9 :
        grade = "A";
        break;
        case 8 :
        grade = "B";
        break;
        case 7:
        grade ="C" ;
        break;
        case 6 :
        grade = "D";
        break;
        default:
        grade = "F";
        }

        }

## While 반복문
while 뒤에 나오는 (조건식) 을 봤을 때 if(조건식) 형태와 유사합니다.
즉 , while 내의 조건식이 true 일 때 , {}내의 실행문이 '반복적으로' 이루어집니다

그래서 주의할 점이 있는데
while 내부의 조건식이 특정 시점에서 false 가 되도록 미리 지정해둘 필요가 있습니다.
false 가 되는 시점을 지정해주지 않는다면 무한히 반복실행문이 실행된다는 점에서 무한루프(infinite loops)라는 표현을 씁니다.

    형식 :
        while (조건식) {
              반복실행문
        }

    while 문을 사용하여
    1 2 3 4 5 6 7 8 9 10
    11 12 ....
    91 92 93 94 95 96 97 98 99 100 
        만드는 방법
            
    int i1 = 1;

    while ( i1 < 101){
            System.out.print(i1 + " ");
            if(i1 % 10 == 0) {
                System.out.println();
            }
            i1++;
        }
         반복을 10번 돌리는법
        int i2 = 1;
        while ( i2 < 101 ) {
            System.out.println(i2 + " " + (i2 + 1) + " " + (i2 + 2) + " " +(i2 + 3) +
                                " " + (i2 +4) + " " + (i2 + 5) + " " +(i2 + 6) +
                                " "  +(i2 + 7) +  " " + (i2 + 8) + " " +(i2 + 9));
        i2 += 10;

        }

## for 반복문 ( for loop )
대부분의 경우에는 명확한 횟수가 고정되어 있을 때 사용하는 반복문

    형식:
     for ( 시작값 ; 종료값 ; 증감값) {
                반복실행문

    Scanner scanner = new Scanner(System.in);
    System.out.print("1부터 몇까지 더하시겠습니까? >>>>>>>");
    int n = scanner.nextInt();
    int sum = 0;
    for(int i = 0; i<11 ; i++){
    sum += i;
    }
    System.out.println("1부터 "+n+" 까지의 합은 "+ sum +" 입니다");

## 중첩 관련
    while 중첩문 형식
        while (조건식1) {
                    반복 실행문1a
                    while(조건식2) {
                        반복실행문2
                 }
                 반복실행문1b
              }
    예시
        int a = 2 ;
        while (a < 10 ) {
            int b = 1;
         while (b < 10) {
             System.out.println(a + "x" + b + "=" + (a * b));
             b++;
         }
         a++;
        }

    for 중첩문 형식
         for(int i = 0; i < 10 ; i++) {
            반복실행문 1-ㅁ
            for(int j = 0; j<10; j++) {
                반복실행문2
         }
        ( 반복실행문1-b)
        for(int k = 0 ; k < 10; k++) {
            반복 실행문3
         }
         (반복실행문 1-c)
        }

    예시

    for ( int i = 0 ; i < 5; i++){
            for(int j = 0; j < i; j++){
                System.out.println("*");          //별이 한번에 여러번 찍힐수 있기 때문에 print로 작성
            }
            System.out.println();                 // 개행이 일어나는 1차 for 문
        }